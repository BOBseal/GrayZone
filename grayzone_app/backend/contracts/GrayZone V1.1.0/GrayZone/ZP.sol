// SPDX-License-Identifier: MIT

/*
LINEA TESTNET = 0xD6cD7CadB5f45680b847dc5Fe926230F4fbae691
""      "" UPGRADEABLE = 0xe9DF3113c2727AaBe5c1F50747c0CB6dB4f0cD0F -- non init
fuse mainnet = 0x98ce6472dd53A65381AD85cdf8AF0A7E2946a9E4
*/
pragma solidity ^0.8.17;


import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "https://github.com/LayerZero-Labs/solidity-examples/blob/main/contracts/lzApp/interfaces/ILayerZeroEndpoint.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/*
v-1.1.0;
Base Module Roles => 
    Normal Module => Have access to modular functions 
    Lender Module => Special Module with Unrestricted access to fund modification related functions
    
Each NFT have => 
    Storage Slots =  Each ID has a Storage Mapping allowing to storage bytes and string data - can be used as data encryption pairing both
    Sharing Of Storage Slots = Allows Sharing of Storage Slots to Specific addresses , ie addresses with permission only can view stored data on slot- by default upto 10 Share Views
    Deletion of Slots =  Storage Slots can be deleted , Temporary of Permanent
    Recovery of Temporary Deletions = Temporary Deletions can be Recovered by paying a fee
    Time Based Expiry =  Each Id has a Timer and a Viewer to mark an Id as Expired or Valid - doesnt affect payments - for other gating purposes
    Omni Chain Marker = Each Id has a Field of Active Chain that denotes the Id to be active on a chain - to be used by LZO modules for crosschain data transfers without locking/burning a token on a chain and using getActiveChain to verify chain status
    Dual Roles =  Each Id has a Minter Role = ie the Original Minter and Holder = current holder
    Revenue Sharing in ETH = Each Id has Facility to Share Revenue generated by an ID to it's original minter - by default it is 2% , can be increased using as needed methods via modules
    Royalty Taxes in Token Payments = pays 1.5 % of each deposit/withdraw/transfer amount to Minter Role (Both Eth and token Fee , in case of eth related id-to-id transfers , fee is paid in eth 1.5% eth royalty + eth revenue sharing)
    Custom Use Based Curreny/Field = A Mapping to store "Points" Balances, Points are gained through function executions or rewarded via modules, Is supposed to be a reward points based currency/identifier for use in as needed case

Lenders can => 
    Lender Modules can Withdraw funds stored in this contract for as needed purpose
    can edit balances of Ids
 
*/

contract ZONEPASS is Initializable,ERC721Upgradeable, ERC721EnumerableUpgradeable{
    using Counters for Counters.Counter;
    //uint16 public constant FUNCTION_TYPE_SEND = 1;
    uint256 internal week = 604800;
    address internal initAcc;
    address internal _feeToken;
    address public _owner;
    uint256 internal feeAmt ; // 0.1% for direct 0.01% for via minter
    uint256 internal directFee; // basefee
    uint256 internal pointsModifier;
    ILayerZeroEndpoint public lzEndpoint;

    struct PASSHOLDER {
        address minter;
        address holder;
        uint16 mintCh; //minting chain for omni modules
        uint16 activeCh; // active chain for omni modules
        uint256 tokenId;
        uint256 mintTime;
        uint256 lastRenewal;
        uint256 nextExpiry;
        uint256 usedSlots;
        uint256 allowedSlots;
        uint256 totalServiceUses;
        mapping(address=>uint256) _20bal; // token balances
        mapping(uint256 => Storage) _storageSlots;
    }

    struct Storage{
        bool deleted;
        string store;
        address storer;
        bytes extra;
    }

    struct Access{
        uint256 slot;
        uint256 accesees;
        uint256 maxShare;
        address [] access;
    }
    //event MINT(address by , uint256 id);
    mapping(address => uint256) public contractAccruedFee;
    mapping(uint256 => PASSHOLDER) public _zonepassmaps;
    mapping(uint256 => Access) public storageViewAccess;
    Counters.Counter internal _tokenIdCounter;
    mapping(address => bool) public modules;
    mapping(address => bool) public lenders;
    // special mapping to set reward rates for ids , should be set by modules on conditions
    mapping(uint256 => uint8) public revenueData;

    //modifier for external contracts
    modifier isModule(){
        require(modules[msg.sender] = true,"not allowed");
        _;
    }
    //modifier for unrestricted funds needing contracts
    modifier isLender(){
        require(lenders[msg.sender] = true,"not allowed");
        _;
    }
    //owner modifier
    modifier onlyOwner(){
        require(msg.sender == _owner);
        _;
    }
    //initialise initializer
    function __fx__() public {
        initAcc = msg.sender;
    }
    //initializer
    function initialize(address weth , string memory name , string memory symbol , address _endpoint) initializer public {
        require(msg.sender == initAcc,"not init acc");
        __ERC721_init_unchained(name, symbol);
        __ERC721Enumerable_init_unchained();
        lzEndpoint = ILayerZeroEndpoint(_endpoint);
        modules[msg.sender] = true;
        _owner = msg.sender;
        _feeToken = weth;
        feeAmt = 2;
        directFee = 0.0001 ether;
        pointsModifier = 3;
        //ONFT721Core(_minGasToTransfer, _lzEndpoint);
    }
    //getApplicableRevenue
    function getRevenueData(uint256 id) public view returns(uint8) {
        uint8 x = revenueData[id];
        if(x != 0) {
            return x;
        }
        else return uint8(2);
    }
    //returns owner of contract
    function owner() public view returns(address){
        return _owner;
    }
    // return the original minting chain for Id
    function getMintChain(uint256 id) public view returns(uint16) {
        return _zonepassmaps[id].mintCh;
    }
    //gets minter 
    function getMinter(uint256 id) public view returns(address){
        return _zonepassmaps[id].minter;
    }
    //get used slots storage -- returns current used and next slot
    function getSlotsUsed(uint256 id) public view returns(uint256, uint256){
        return (_zonepassmaps[id].usedSlots,_zonepassmaps[id].usedSlots +1 );
    }
    //return current chain 
    function getActiveChain(uint256 id) public view returns(uint16){
        return _zonepassmaps[id].activeCh;
    }
    //returns balances for a token of an pass id , Zero Address stands for ETH/NATIVE
    function getIdBalance(address token , uint256 id) public view returns(uint256){
        return _zonepassmaps[id]._20bal[token];
    }
    //return points value for an Id
    function getIdPoints(uint256 id) public view returns(uint256) {
        return _zonepassmaps[id].totalServiceUses;
    }
    //just a getter for deployment controls
    function getInitializer() public view returns(address){
        return initAcc;
    }
    //storage access share verifier for an address , user => address to check , id and slot => to check for user
    function haveStorageAccess(address user , uint256 id , uint256 slot) public view returns(bool){
        bool x = false;
        for(uint256 i ; i< storageViewAccess[id].access.length ; i++){
            address b = storageViewAccess[id].access[i];
            if(b == user && slot == storageViewAccess[id].slot){
                x = true;
                break;
            }
        }
        return x;
    }
    //fee required to recover a temporarily deleted storage slot
    function getRecoveryFee() public view returns(uint256){
        return directFee * 5;
    }
    //return storage data : string => uri or salt , bytes => other params or encoded uri 
    function getStorage(address by, uint256 id , uint256 slot) public view returns(string memory , bytes memory){
        require(by == _zonepassmaps[id]._storageSlots[slot].storer || 
        haveStorageAccess(by , id , slot) == true,"not owner of id and slot");
        require(_zonepassmaps[id]._storageSlots[slot].deleted == false,"Deleted Slot");
        return (_zonepassmaps[id]._storageSlots[slot].store,_zonepassmaps[id]._storageSlots[slot].extra);
    }
    //validum to check active validity of a id
    function isExpired(uint256 id) public view returns(bool){
        if(block.timestamp > _zonepassmaps[id].nextExpiry){
            return true;
        }
        return false;
    }
    //gets fee token address
    function getFeeToken() public view returns(address){
        return _feeToken;
    }
    //get fee needed per week to extend expiry
    function getWeeklyFee() public view returns(address token , uint256 amount){
        return (_feeToken , directFee);
    }
    //...yk what this is
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721Upgradeable)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {
        return  super.supportsInterface(interfaceId);
    }

    //write functions 

    //set revenue data for an id 
    function setRev(uint256 id , uint8 percent) public payable isModule{
        revenueData[id] =revenueData[id]+ percent;
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
    }
    //set current chain -- to be used by omni modules
    function setActiveChain(uint256 tokenId , uint16 chainId) public isModule{
        _zonepassmaps[tokenId].activeCh = chainId;
    }
    //layerzero endpoint
    function setLzPoint(address endPoint) public onlyOwner {
        lzEndpoint = ILayerZeroEndpoint(endPoint);
    }
    //contract ownership transfer
    function transferOwnership(address nOwner) public onlyOwner{
        _owner = nOwner;
    }
    //allows sharing view access of a slot of a id to an address
    function shareStorage(uint256 id , uint256 slot , address to) public payable{
        Storage storage Store = _zonepassmaps[id]._storageSlots[slot];
        require(storageViewAccess[id].access.length < storageViewAccess[id].maxShare, "max share allowed 10 by default");
        require(msg.sender == _zonepassmaps[id].holder || msg.sender == _zonepassmaps[id].minter,"not owner of id ");
        require(msg.sender == Store.storer && Store.deleted == false,"no access to slot or deleted slot");
        incrementTotalServices(id);
        storageViewAccess[id].slot = slot;
        storageViewAccess[id].access.push(to);
        storageViewAccess[id].accesees ++;
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
        //emit SHAREVIEW(id , slot , msg.sender , to);
    }
    //base fee amount => is also the weekly fee/fee for a week
    function changeDirectFee(uint256 newAmt) public onlyOwner{
        directFee = newAmt;
    }
    //remove storage view access from an address
    function removeShare(uint256 id , uint256 slot , address to) public payable{
        require(msg.sender == _zonepassmaps[id].holder || msg.sender == _zonepassmaps[id].minter,"not owner of id ");
        require(msg.sender == _zonepassmaps[id]._storageSlots[slot].storer && _zonepassmaps[id]._storageSlots[slot].deleted == false,"no access to slot or deleted slot");
        incrementTotalServices(id);
        storageViewAccess[id].slot = slot;
        
        for (uint256 i ; i< storageViewAccess[id].maxShare; i++){
            address a = storageViewAccess[id].access[i];
            if(a == to){
                delete storageViewAccess[id].access[i];
                storageViewAccess[id].accesees -1;
                break;
            }
        }
        
        //storageViewAccess[id].access.push(to);
        storageViewAccess[id].accesees -1;
       // emit SHAREVIEW(id , slot , msg.sender , to);
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
    }
    //adds a string and a bytes param to id storage
    function addToStorage(string memory hash , uint256 id , bytes memory extraData , address by , uint256 slotNo) public payable isModule{
        require(_zonepassmaps[id].holder == by,"not holder");
        require(slotNo <_zonepassmaps[id].allowedSlots && block.timestamp < _zonepassmaps[id].nextExpiry,"slot exceed or expired");
        Storage storage Store = _zonepassmaps[id]._storageSlots[slotNo];
        _zonepassmaps[id].usedSlots ++;
        incrementTotalServices(id);
        Store.store = hash;
        Store.extra = extraData;
        Store.storer = by;
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
    }
    //deletes a storage slot
    function delFromStorage(uint256 id, uint256 slot , address storer) public payable isModule{
        Storage storage Store = _zonepassmaps[id]._storageSlots[slot];
        require(slot <=_zonepassmaps[id].usedSlots && block.timestamp < _zonepassmaps[id].nextExpiry,"slot exceed");
        require(storer == Store.storer && storer == _zonepassmaps[id].holder, "did not store data slot");
        //_zonepassmaps[id].usedSlots - 1;
        incrementTotalServices(id);
        Store.deleted = true;
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
    }
    //recover a deleted slot data
    function recoverData( uint256 id , uint256 slot , bool paywithpass) public payable{
        PASSHOLDER storage pass = _zonepassmaps[id];
        require(msg.sender == pass.holder || msg.sender== pass.minter,"not access to id ");
        require(msg.sender == pass._storageSlots[slot].storer,"no access to slot");
        if(msg.sender == pass.holder && paywithpass == true)
        {
            require(pass._20bal[_feeToken] >= directFee * 5,"need fee");
            pass._20bal[_feeToken] = pass._20bal[_feeToken] - (directFee * 5);
            contractAccruedFee[_feeToken] =contractAccruedFee[_feeToken] + directFee * 5;
        }
        if(msg.sender == pass.holder && paywithpass == false) {
            require(IERC20(_feeToken).balanceOf(msg.sender)>= directFee * 5  ,"need fee");
            IERC20(_feeToken).transferFrom(msg.sender , address(this), directFee * 5);
            contractAccruedFee[_feeToken] =contractAccruedFee[_feeToken] + directFee * 5;
        }
        if(msg.sender == pass.minter) {
            require(IERC20(_feeToken).balanceOf(msg.sender)>= directFee * 5  ,"need fee");
            IERC20(_feeToken).transferFrom(msg.sender , address(this), directFee * 5);
            contractAccruedFee[_feeToken] =contractAccruedFee[_feeToken] + directFee * 5;
        }
        incrementTotalServices(id);
        pass._storageSlots[slot].deleted = false;
       // emit STORAGERECOVER(id, slot ,msg.sender);
    }
    //increment points of an id
    function incrementServices(uint256 id , uint256 num) public payable isModule{
        _zonepassmaps[id].totalServiceUses=_zonepassmaps[id].totalServiceUses + num;
    }
    //decrement points of an id
    function decrementServices(uint256 id , uint256 num) public payable isModule{
        _zonepassmaps[id].totalServiceUses = _zonepassmaps[id].totalServiceUses - num;
    }
    //mint function -  tokenId is to be controlled via minter that has omni counter
    function mint(address to , uint256 tokenId) public payable isModule{
        require(_exists(tokenId)== false,"already minted");
        PASSHOLDER storage pass = _zonepassmaps[tokenId];
        uint16 ch = lzEndpoint.getChainId();
        _safeMint(to, tokenId);
        //_setTokenURI(tokenId, uri);
        pass.holder = to;
        pass.minter = to;
        pass.mintTime = block.timestamp;
        pass.nextExpiry = block.timestamp + 31536000; // one year
        incrementTotalServices(tokenId);
        pass.allowedSlots = 200;
        pass.mintCh = ch;
        pass.activeCh = ch;
        pass.tokenId = tokenId;
        storageViewAccess[tokenId].maxShare = 10;
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
    }
    //storage view access share limit extender
    function increaseMaxShare(uint id, uint256 slot,uint256 incNum, address by) public payable isModule{
        require(by == _zonepassmaps[id]._storageSlots[slot].storer);
        storageViewAccess[id].maxShare = storageViewAccess[id].maxShare + incNum;
    }
    //increase storage slot limit for an id
    function increaseSlots(uint256 slots, uint256 id) public isModule{
        require(id < _tokenIdCounter.current(),"non existent id");
        _zonepassmaps[id].allowedSlots = _zonepassmaps[id].allowedSlots + slots;
        //emit EXTENDSLOTS(id , slots , by);
    }
    function setUri(uint id , string memory uri_) public payable isModule{
       require(_exists(id)== true);
       _setUri(id , uri_);
       if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
    }
    //extend expiry time of an id
    function extendPassTime(uint256 id , uint256 time) public payable isModule {
        require(id < _tokenIdCounter.current(),"non existent id");
        _zonepassmaps[id].lastRenewal = block.timestamp;
        _zonepassmaps[id].nextExpiry = _zonepassmaps[id].nextExpiry + time;
        incrementTotalServices(id);
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
      //  emit EXPIRYEXTEND(id , time , by);
    }
    // extend expiry but directly from here in terms of weeks
    function boostPass(uint256 timeInWeeks ,uint256 id) public payable {
        require(IERC20(_feeToken).balanceOf(msg.sender)>= directFee * timeInWeeks,"Recharge first");
        require(msg.sender == _zonepassmaps[id].holder);
        IERC20(_feeToken).transferFrom(msg.sender , address(this), (directFee * timeInWeeks));
        _zonepassmaps[id]._20bal[_feeToken] = _zonepassmaps[id]._20bal[_feeToken] - (directFee * timeInWeeks);
        _zonepassmaps[id].lastRenewal = block.timestamp;
        _zonepassmaps[id].nextExpiry = _zonepassmaps[id].nextExpiry + (timeInWeeks * week);
        incrementTotalServices(id);
      
      //  emit EXPIRYEXTEND(id , timeInWeeks * week , by);
    }
    //deposit and erc20 to an id - pay 1.5% fee to og minter
    function deposit(uint256 id , address token , uint256 amt, address from) public payable isModule{
        require(_exists(id) == true,"non existent id");
        require(IERC20(token).balanceOf(from) >= amt,"no bal");
        IERC20(token).transferFrom(from , address(this) , amt);
        uint256 fee = (amt * 15)/1000;
        _zonepassmaps[id]._20bal[token] = _zonepassmaps[id]._20bal[token] + (amt - fee);
        incrementTotalServices(id);
        address m =_zonepassmaps[id].minter;
        if(m != address(0)) {
            IERC20(token).transfer(m, fee);
        }
        if(msg.value >0 && m != address(0)) {
            uint rev = uint256(revenueData[id]);
            if(rev == 0){
                //default rate = 2%
                rev = 2;
            } 
            uint256 f = msg.value * rev /100;
            //pay minter rev
            payable(m).transfer(f);
            contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + (msg.value - f);
        }
    }
    //withdraw an erc20 from an id
    function withdraw(uint256 id , address token , uint256 amt , address to , address from) public payable isModule{
        require(_exists(id) == true && token != address(0),"non existent id");
        require(IERC20(token).balanceOf(address(this)) >= amt && _zonepassmaps[id]._20bal[token] >= amt,"no bal");
        require( from == _zonepassmaps[id].holder,"not owner");
        uint256 fee = (amt * 15)/1000;
        _zonepassmaps[id]._20bal[token] =_zonepassmaps[id]._20bal[token] - amt;
        IERC20(token).transfer(to , (amt - fee));
        incrementTotalServices(id);
        address m =_zonepassmaps[id].minter;
        if(m != address(0)) {
            IERC20(token).transfer(m, fee);
        }
        if(msg.value >0 && m != address(0)) {
            uint rev = uint256(revenueData[id]);
            if(rev == 0){
                //default rate = 2%
                rev = 2;
            } 
            uint256 f = msg.value * rev /100;
            //pay minter rev
            payable(m).transfer(f);
            contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + (msg.value - f);
        }
    }
    //transfer of token from id to id - use Zero Address  for Native transfers
    function idToId( uint256 fromId , uint256 toId , address token , uint256 amount) public payable isModule{
        require(_zonepassmaps[fromId]._20bal[token] >= amount,"no bal");
        require(_exists(fromId) == true && _exists(toId)== true);
        uint256 fee = (amount * 15)/1000;
        _zonepassmaps[fromId]._20bal[token] = _zonepassmaps[fromId]._20bal[token] - amount;
        _zonepassmaps[toId]._20bal[token] = _zonepassmaps[toId]._20bal[token] + (amount - fee);
        incrementTotalServices(fromId);
        address m =_zonepassmaps[fromId].minter;
        if(m != address(0)) {
            IERC20(token).transfer(m, fee);
        }
        if(msg.value >0 && m != address(0)) {
            uint rev = uint256(revenueData[fromId]);
            if(rev == 0){
                //default rate = 2%
                rev = 2;
            } 
            uint256 f = msg.value * rev /100;
            //pay minter rev
            payable(m).transfer(f);
            contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + (msg.value - f);
        }
      //  emit IDBALTRANSFER(fromId , toId , token , amount);
    }
    //deposit eth to an id
    function depositEth(uint256 id , uint256 amount) public payable{
        require(_exists(id)== true);
        require(msg.value >= amount,"send fee");
        address m = _zonepassmaps[id].minter;
        uint256 r = msg.value - amount;
        if(r >0 && m != address(0)) {
            uint rev = uint256(revenueData[id]);
            if(rev == 0){
                //default rate = 2%
                rev = 2;
            } 
            uint256 f = r * rev /100;
            //pay minter rev
            payable(m).transfer(f);
            contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + (r - f);
        }
        _zonepassmaps[id]._20bal[address(0)] = _zonepassmaps[id]._20bal[address(0)] + amount;
        incrementTotalServices(id);
    }
    //unchecked modify balance of id , to be used by lending modules and swappers
    function addBal(uint256 id,address token ,uint256 amount) public payable isLender{
        _zonepassmaps[id]._20bal[token] = _zonepassmaps[id]._20bal[token] + amount;
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
    }
    //unchecked modify balance of id , to be used by lending modules and swappers
    function subBal(uint256 id,address token ,uint256 amount) public payable isLender{
        _zonepassmaps[id]._20bal[token] = _zonepassmaps[id]._20bal[token] - amount;
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
    }
    //withdraw eth from an id to address
    function withdrawEth(uint256 id , uint256 amount , address to , address from) public payable{
        require(_exists(id)== true);
        require(address(this).balance >= amount && _zonepassmaps[id]._20bal[address(0)] >= amount,"no bal");
        require( from == _zonepassmaps[id].holder,"not owner");
        _zonepassmaps[id]._20bal[address(0)] =_zonepassmaps[id]._20bal[address(0)] - amount;
        address m = _zonepassmaps[id].minter;
        payable(to).transfer(amount);
        if(msg.value >0 && m != address(0)) {
            uint rev = uint256(revenueData[id]);
            if(rev == 0){
                //default rate = 2%
                rev = 2;
            } 
            uint256 f = msg.value * rev /100;
            //pay minter rev
            payable(m).transfer(f);
            contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + (msg.value - f);
        }
    }
    //transfer points from id to id
    function transferPoints(uint256 fromId , uint256 toId , uint256 amount) public payable isModule{
        require(_zonepassmaps[fromId].totalServiceUses >= amount);
        _zonepassmaps[fromId].totalServiceUses = _zonepassmaps[fromId].totalServiceUses - amount;
        _zonepassmaps[toId].totalServiceUses = _zonepassmaps[toId].totalServiceUses + amount;
        address m = _zonepassmaps[fromId].minter;
        if(msg.value >0 && m != address(0)) {
            uint rev = uint256(revenueData[fromId]);
            if(rev == 0){
                //default rate = 2%
                rev = 2;
            } 
            uint256 f = msg.value * rev /100;
            //pay minter rev
            payable(m).transfer(f);
            contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + (msg.value - f);
        }
    }
    //set direct fee -- also per week fee
    function setDirectFee(uint256 amount) public onlyOwner{
        directFee = amount;
    }
    //set fee token
    function setFeeToken(address token) public onlyOwner {
        _feeToken = token;
    }
    //points modifier=> this decides the points to be added for each interaction from within this contract
    function setPointsM(uint256 _modifier) public onlyOwner{
        pointsModifier = _modifier;
    } 
    //lender / unchecked withdraw for unrestricted fund flow needing modules -- require fee in native equal to 0.1% of withdrawn amount
    function withdrawCaErc(address token , uint256 amount) public payable isLender {
        require(amount <= IERC20(token).balanceOf(address(this)) , "No balances");
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
        contractAccruedFee[token] = contractAccruedFee[token] - amount;
        IERC20(token).transfer(msg.sender , amount);
    }
    //lender / unchecked withdraw for unrestricted fund flow needing modules
    function withdrawCaEth(uint amount) public payable isLender{
        address token = address(0);
        require(amount <= address(this).balance, "No balances");
        if(msg.value >0) {
        contractAccruedFee[address(0)] = contractAccruedFee[address(0)] + msg.value;
        }
        contractAccruedFee[token] = contractAccruedFee[token] - amount;
        payable(msg.sender).transfer(amount);
    }
    //withdraw contract accumulated revenue
    function withdrawRevenueErc(address token , uint256 amount) public onlyOwner {
        require(amount <= contractAccruedFee[token] , "No balances");
        contractAccruedFee[token] = contractAccruedFee[token] - amount;
        IERC20(token).transfer(msg.sender , amount);
    }
    //withdraw contract accumulated revenue
    function withdrawRevenueEth(uint amount) public onlyOwner{
        address token = address(0);
        require(amount <= contractAccruedFee[token] , "No balances");
        contractAccruedFee[token] = contractAccruedFee[token] - amount;
        payable(msg.sender).transfer(amount);
    }
    //add module address
    function addModule(address minter_) public onlyOwner{
       // require(index < ~uint16(0) ,"max modules reach");
      //  require(minters[index] == address(0),"minter exist in index");
        modules[minter_] = true;
    }
    //remove module
    function removeModule(address minter) public onlyOwner{
        modules[minter] = false;
    }
    //add lender 
    function addLender(address minter_) public onlyOwner{
       // require(index < ~uint16(0) ,"max modules reach");
      //  require(minters[index] == address(0),"minter exist in index");
        lenders[minter_] = true;
    }
    //remove lender
    function removeLender(address minter) public onlyOwner{
        lenders[minter] = false;
    }
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)
        internal
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)
    {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
        _zonepassmaps[tokenId].holder = to;
    }
    function _burn(uint256 tokenId) internal override(ERC721Upgradeable) {
        super._burn(tokenId);
        _zonepassmaps[tokenId].holder = address(0);
    }
    function incrementTotalServices(uint256 id) internal {
        _zonepassmaps[id].totalServiceUses= _zonepassmaps[id].totalServiceUses + pointsModifier;
    }
}